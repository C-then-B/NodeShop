import { staticImplements } from '../util/staticImplements';
import {
  IDatabaseModel,
  IDatabaseModelStatic
} from '../interfaces/IDatabaseModel';

import { DatabaseController as db } from '../controllers/database';
import { QueryResult } from 'pg';

import { CartProduct } from './cartProduct';
import { User } from './user';
import { setUser } from '../controllers/auth';

//@staticImplements<IDatabaseModelStatic>()
class Cart implements IDatabaseModel {
  id: number = NaN;
  session: Express.Session;
  belongsToUser: User | undefined = undefined;
  cartProducts: CartProduct[] = [];

  static tableName = 'Carts';

  constructor(session: Express.Session) {
    this.belongsToUser = session.user;
    this.session = session;
  }

  static async init(databaseController: db): Promise<QueryResult> {
    return db.query(
      `CREATE TABLE IF NOT EXISTS ${Cart.tableName}(
          id INT NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          updatedAt TIMESTAMPTZ NOT NULL,
          createdAt TIMESTAMPTZ NOT NULL,
          belongsToUser INT NOT NULL REFERENCES ${User.tableName}(id) ON DELETE CASCADE ON UPDATE CASCADE
        )`
    );
  }

  async save(): Promise<QueryResult> {
    // Does the cart exist in the app
    let result = !isNaN(this.id);

    const now = new Date();
    if (!result) {
      return new Promise<QueryResult<any>>(res => {
        db.query(
          `INSERT INTO ${Cart.tableName} (updatedAt, createdAt, belongsToUser) VALUES ($1, $1, $2) RETURNING *`,
          [now, this.belongsToUser!.id]
        ).then(result => {
          this.id = result.rows[0].id;
          res(result);
        });
      });
    } else {
      return db.query(`UPDATE ${Cart.tableName} SET updatedAt=$1 WHERE id=$2`, [
        now,
        this.id
      ]);
    }
  }

  delete(): Promise<QueryResult> {
    return new Promise<QueryResult>(async resolve => {
      for (const product of this.cartProducts) {
        await this.deleteProduct(product.product.id);
      }

      db.query(`DELETE FROM ${Cart.tableName} WHERE id=$1`, [this.id]).then(
        result => {
          resolve(result);
        }
      );
    });
  }

  async load(): Promise<void> {
    return new Promise<void>(resolve => {
      db.query(`SELECT * FROM ${Cart.tableName} WHERE belongsToUser=$1`, [
        this.belongsToUser!.id
      ])
        .then(async result => {
          // This user has no cart yet
          if (result.rowCount === 0) {
            await this.save(); // this assigns id

            resolve();
          } else {
            this.id = result.rows[0].id;
            // get all cartItems with this id, populate array

            CartProduct.fetchAllBelongingToCart(this.id)
              .then(result => {
                // Sort cartProducts by the time they were added to the cart
                this.cartProducts = result.sort((a, b) => {
                  return +new Date(a.createdAt!) - +new Date(b.createdAt!);
                });

                resolve();
              })
              .catch(err => console.log(err));
          }
        })
        .catch(err => console.log(err));
    });
  }

  async addProduct(productID: number): Promise<void> {
    const cartProductIndex = this.cartProducts.findIndex(
      cartProduct => cartProduct.product.id === productID
    );
    let cartProduct = this.cartProducts[cartProductIndex];
    if (cartProduct) {
      cartProduct.quantity++;
    } else {
      cartProduct = new CartProduct(this.id, 1);
      await cartProduct.setup(productID);
      this.cartProducts.push(cartProduct);
    }

    await cartProduct.save();

    return new Promise<void>(async resolve => {
      await this.save();
      resolve();
    });
  }

  async deleteProduct(productID: number): Promise<void> {
    const cartProductIndex = this.cartProducts.findIndex(
      cartProduct => cartProduct.product.id === productID
    );
    let cartProduct = this.cartProducts[cartProductIndex];
    await cartProduct.delete();

    this.cartProducts.splice(cartProductIndex, 1);

    return new Promise<void>(async resolve => {
      await this.save();
      resolve();
    });
  }

  getTotalPrice(): Promise<number> {
    return new Promise<number>(resolve => {
      let totalPrice = 0;
      for (const cartProduct of this.cartProducts) {
        for (let i = 0; i < cartProduct.quantity; i++) {
          totalPrice += cartProduct.product.price;
        }
      }

      resolve(totalPrice);
    });
  }
}

export { Cart };
