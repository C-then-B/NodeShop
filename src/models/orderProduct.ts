import { staticImplements } from '../util/staticImplements';
import {
  IDatabaseModel,
  IDatabaseModelStatic
} from '../interfaces/IDatabaseModel';

import { DatabaseController as db } from '../controllers/database';
import { QueryResult } from 'pg';

import { Product } from './product';
import { Order } from './order';

//@staticImplements<IDatabaseModelStatic>()
class OrderProduct implements IDatabaseModel {
  id: number;
  belongsToOrder: number;
  quantity: number;
  product: Product = new Product('', '', '', 0);

  static tableName = 'OrderProducts';

  static async init(databaseController: db): Promise<QueryResult> {
    return db.query(
      `CREATE TABLE IF NOT EXISTS ${OrderProduct.tableName}(
          id INT NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          belongsToOrder INT NOT NULL REFERENCES ${Order.tableName}(id) ON DELETE CASCADE ON UPDATE CASCADE,
          productID INT NOT NULL REFERENCES ${Product.tableName}(id) ON DELETE CASCADE ON UPDATE CASCADE,
          quantity INT NOT NULL,
          updatedAt TIMESTAMPTZ NOT NULL,
          createdAt TIMESTAMPTZ NOT NULL
        )`
    );
  }

  constructor(belongsToOrder: number, quantity: number, id?: number) {
    this.id = id !== undefined ? id : NaN;
    this.belongsToOrder = belongsToOrder;
    this.quantity = quantity;
  }

  async setup(productID: number) {
    return Product.findByID(productID).then(
      product => (this.product = product)
    );
  }

  async save(): Promise<QueryResult> {
    // Does the orderProduct exist in the app
    let result = !isNaN(this.id);

    // Even if so, does it for some reason not exist in the DB?
    // Maybe someone manually inserted a faulty ID into the URL
    if (result) {
      await db
        .query(
          `SELECT EXISTS(select 1 from ${OrderProduct.tableName} where id=$1)`,
          [this.product.id]
        )
        .then(res => {
          result = res.rows[0].exists;
        });
    }

    const now = new Date();
    if (!result) {
      return new Promise<QueryResult<any>>(res => {
        db.query(
          `INSERT INTO ${OrderProduct.tableName} (belongsToOrder, productID, quantity, updatedAt, createdAt) VALUES ($1, $2, $3, $4, $4) RETURNING *`,
          [this.belongsToOrder, this.product.id, this.quantity, now]
        ).then(result => {
          this.id = result.rows[0].id;
          res(result);
        });
      });
    } else {
      return db.query(
        `UPDATE ${OrderProduct.tableName} SET quantity=$1, updatedAt=$2 WHERE id=$3`,
        [this.quantity, now, this.id]
      );
    }
  }

  delete(): Promise<QueryResult> {
    return db.query(`DELETE FROM ${OrderProduct.tableName} WHERE id=$1`, [
      this.id
    ]);
  }

  static fetchAllBelongingToOrder(cartID: number): Promise<OrderProduct[]> {
    return new Promise<OrderProduct[]>(resolve => {
      db.query(
        `SELECT * FROM ${OrderProduct.tableName} WHERE belongsToOrder=$1`,
        [cartID]
      )
        .then(async result => {
          const cartProducts: OrderProduct[] = [];
          for (const row of result.rows) {
            await this.createInstanceFromDB(row).then(result => {
              cartProducts.push(result!);
            });
          }
          resolve(cartProducts);
        })
        .catch(err => console.log(err));
    });
  }

  private static async createInstanceFromDB(
    dbProduct: any
  ): Promise<OrderProduct | undefined> {
    if (dbProduct === undefined) {
      return undefined;
    }

    const cartProduct = new OrderProduct(
      dbProduct.belongsToOrder,
      dbProduct.quantity,
      dbProduct.id
    );

    await cartProduct.setup(dbProduct.productid);
    return cartProduct;
  }
}

export { OrderProduct };
