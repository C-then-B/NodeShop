import { staticImplements } from '../util/staticImplements';
import {
  IDatabaseModel,
  IDatabaseModelStatic
} from '../interfaces/IDatabaseModel';

import { DatabaseController as db } from '../controllers/database';
import { QueryResult } from 'pg';

import { v4 as uuid } from 'uuid';

@staticImplements<IDatabaseModelStatic>()
class User implements IDatabaseModel {
  id: number;
  name: string;
  email: string;
  hashedPassword: string;
  resetToken: string | undefined;
  resetTokenExpiryDate: Date | undefined;

  static tableName = 'Users';

  constructor(
    name: string,
    email: string,
    hashedPassword: string,
    id?: number,
    resetToken?: string,
    resetTokenExpiryDate?: Date
  ) {
    this.id = id !== undefined ? id : NaN;
    this.name = name;
    this.email = email;
    this.hashedPassword = hashedPassword;
    this.resetToken = resetToken;
    this.resetTokenExpiryDate = resetTokenExpiryDate;
  }

  static async init(databaseController: db): Promise<QueryResult> {
    return db.query(
      `CREATE TABLE IF NOT EXISTS ${User.tableName}(
          id INT NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          email VARCHAR(255) NOT NULL,
          password VARCHAR(255) NOT NULL,
          resetToken VARCHAR(255),
          resetTokenExpiryDate TIMESTAMPTZ,
          updatedAt TIMESTAMPTZ NOT NULL,
          createdAt TIMESTAMPTZ NOT NULL
        )`
    );
  }

  static createGuest = (): Promise<User> => {
    return new Promise<User>(resolve => {
      const user = new User('Guest', uuid(), uuid());
      user.save().then(() => {
        resolve(user);
      });
    });
  };

  async save(): Promise<QueryResult> {
    // Does the user exist in the app
    let result = !isNaN(this.id);

    // Even if so, does it for some reason not exist in the DB?
    // Maybe someone manually inserted a faulty ID into the URL
    if (result) {
      await db
        .query(`SELECT EXISTS(select 1 from ${User.tableName} where id=$1)`, [
          this.id
        ])
        .then(res => {
          result = res.rows[0].exists;
        });
    }

    const now = new Date();
    if (!result) {
      return new Promise<QueryResult<any>>(res => {
        db.query(
          `INSERT INTO ${User.tableName} (name, email, password, updatedAt, createdAt) VALUES ($1, $2, $3, $4, $4) RETURNING *`,
          [this.name, this.email, this.hashedPassword, now]
        ).then(result => {
          this.id = result.rows[0].id;
          res(result);
        });
      });
    } else {
      return db.query(
        `UPDATE ${User.tableName} SET name=$1, email=$2, password=$3, resetToken=$4, resetTokenExpiryDate=$5, updatedAt=$6 WHERE id=$7`,
        [
          this.name,
          this.email,
          this.hashedPassword,
          this.resetToken,
          this.resetTokenExpiryDate,
          now,
          this.id
        ]
      );
    }
  }

  delete(): Promise<QueryResult> {
    return db.query(`DELETE FROM ${User.tableName} WHERE id=$1`, [this.id]);
  }

  static fetchAll(): Promise<User[]> {
    return new Promise<User[]>(resolve => {
      db.query(`SELECT * FROM ${User.tableName}`)
        .then(result => {
          let users: User[] = [];
          for (const row of result.rows) {
            users.push(this.createInstanceFromDB(row)!);
          }
          resolve(users);
        })
        .catch(err => console.log(err));
    });
  }

  static findByColumn(column: string, value: any): Promise<User | undefined> {
    return new Promise<any>(resolve => {
      db.query(`SELECT * FROM ${User.tableName} WHERE ${column}=$1`, [value])
        .then(result => {
          resolve(this.createInstanceFromDB(result.rows[0]));
        })
        .catch(err => console.log(err));
    });
  }

  // Convenience
  static findByEmail(email: string): Promise<User | undefined> {
    return this.findByColumn('email', email);
  }

  static createInstanceFromDB(dbProduct: any): User | undefined {
    if (dbProduct === undefined) {
      return undefined;
    }

    return new User(
      dbProduct.name,
      dbProduct.email,
      dbProduct.password,
      dbProduct.id,
      dbProduct.resettoken,
      dbProduct.resettokenexpirydate
    );
  }
}

export { User };
