"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const database_1 = require("../controllers/database");
const cartProduct_1 = require("./cartProduct");
//@staticImplements<IDatabaseModelStatic>()
class Cart {
    constructor(belongsToUser) {
        this.id = NaN;
        this.cartProducts = [];
        //this.id = id !== undefined ? id : NaN;
        this.belongsToUser = belongsToUser;
    }
    static init(databaseController) {
        return __awaiter(this, void 0, void 0, function* () {
            return database_1.DatabaseController.query(`CREATE TABLE IF NOT EXISTS ${Cart.tableName}(
          id INT NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          updatedAt TIMESTAMPTZ NOT NULL,
          createdAt TIMESTAMPTZ NOT NULL,
          belongsToUser INT NOT NULL REFERENCES Users(id) ON DELETE CASCADE ON UPDATE CASCADE
        )`);
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            // Does the cart exist in the app
            let result = !isNaN(this.id);
            // Even if so, does it for some reason not exist in the DB?
            // Maybe someone manually inserted a faulty ID into the URL
            if (result) {
                yield database_1.DatabaseController
                    .query(`SELECT EXISTS(select 1 from ${Cart.tableName} where id=$1)`, [
                    this.id
                ])
                    .then(res => {
                    result = res.rows[0].exists;
                });
            }
            const now = new Date();
            if (!result) {
                return new Promise(res => {
                    database_1.DatabaseController.query(`INSERT INTO ${Cart.tableName} (updatedAt, createdAt, belongsToUser) VALUES ($1, $1, $2) RETURNING *`, [now, this.belongsToUser]).then(result => {
                        this.id = result.rows[0].id;
                        res(result);
                    });
                });
            }
            else {
                return database_1.DatabaseController.query(`UPDATE ${Cart.tableName} SET updatedAt=$1 WHERE id=$2`, [
                    now,
                    this.id
                ]);
            }
        });
    }
    delete() {
        return database_1.DatabaseController.query(`DELETE FROM ${Cart.tableName} WHERE id=$1`, [this.id]);
    }
    load() {
        if (this.belongsToUser === NaN) {
            console.error("Can't load cart without passing user!");
            return Promise.resolve();
        }
        return new Promise(resolve => {
            database_1.DatabaseController.query(`SELECT * FROM ${Cart.tableName} WHERE belongsToUser=$1`, [
                this.belongsToUser
            ])
                .then(result => {
                // This user has no cart yet
                if (result.rowCount === 0) {
                    return this.save(); // this assigns id
                }
                else {
                    this.id = result.rows[0].id;
                    // get all cartItems with this id, populate array
                    cartProduct_1.CartProduct.fetchAllBelongingToCart(this.id).then(result => {
                        this.cartProducts = result;
                        resolve();
                    });
                }
            })
                .catch(err => console.log(err));
        });
    }
    addProduct(productID) {
        return __awaiter(this, void 0, void 0, function* () {
            const cartProductIndex = this.cartProducts.findIndex(cartProduct => cartProduct.product.id === productID);
            let cartProduct = this.cartProducts[cartProductIndex];
            if (cartProduct) {
                cartProduct.quantity++;
            }
            else {
                cartProduct = new cartProduct_1.CartProduct(this.id, 1);
                yield cartProduct.setup(productID);
                this.cartProducts.push(cartProduct);
            }
            yield cartProduct.save();
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.save();
                resolve();
            }));
        });
    }
    deleteProduct(productID) {
        return __awaiter(this, void 0, void 0, function* () {
            const cartProductIndex = this.cartProducts.findIndex(cartProduct => cartProduct.product.id === productID);
            let cartProduct = this.cartProducts[cartProductIndex];
            console.log(cartProduct);
            yield cartProduct.delete();
            this.cartProducts.splice(cartProductIndex, 1);
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.save();
                resolve();
            }));
        });
    }
    getTotalPrice() {
        return new Promise(resolve => {
            let totalPrice = 0;
            for (const cartProduct of this.cartProducts) {
                for (let i = 0; i < cartProduct.quantity; i++) {
                    totalPrice += cartProduct.product.price;
                }
            }
            resolve(totalPrice);
        });
    }
}
exports.Cart = Cart;
Cart.tableName = 'Carts';
//# sourceMappingURL=cart copy.js.map