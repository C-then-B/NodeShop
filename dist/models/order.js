"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const database_1 = require("../controllers/database");
const user_1 = require("./user");
const orderProduct_1 = require("./orderProduct");
//@staticImplements<IDatabaseModelStatic>()
class Order {
    constructor(id, belongsToUser) {
        this.id = NaN;
        this.belongsToUser = NaN;
        this.orderProducts = [];
        if ((belongsToUser === undefined || isNaN(belongsToUser)) &&
            (id === undefined || isNaN(id))) {
            console.error('either assign id or belongsToUser!');
        }
        this.id = id !== undefined && !isNaN(id) ? id : NaN;
        this.belongsToUser =
            belongsToUser !== undefined && !isNaN(belongsToUser)
                ? belongsToUser
                : NaN;
        // Remember to call setup()
    }
    static init(databaseController) {
        return __awaiter(this, void 0, void 0, function* () {
            return database_1.DatabaseController.query(`CREATE TABLE IF NOT EXISTS ${Order.tableName}(
          id INT NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          updatedAt TIMESTAMPTZ NOT NULL,
          orderedAt TIMESTAMPTZ NOT NULL,
          belongsToUser INT NOT NULL REFERENCES ${user_1.User.tableName}(id) ON DELETE CASCADE ON UPDATE CASCADE
        )`);
        });
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!isNaN(this.id)) {
                return this.load();
            }
            else {
                return this.save();
            }
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            const now = new Date();
            if (isNaN(this.id)) {
                return new Promise(res => {
                    database_1.DatabaseController.query(`INSERT INTO ${Order.tableName} (updatedAt, orderedAt, belongsToUser) VALUES ($1, $1, $2) RETURNING *`, [now, this.belongsToUser]).then(result => {
                        this.id = result.rows[0].id;
                        res(result);
                    });
                });
            }
            else {
                return database_1.DatabaseController.query(`UPDATE ${Order.tableName} SET updatedAt=$1 WHERE id=$2`, [now, this.id]);
            }
        });
    }
    delete() {
        return database_1.DatabaseController.query(`DELETE FROM ${Order.tableName} WHERE id=$1`, [this.id]);
    }
    load() {
        return new Promise(resolve => {
            database_1.DatabaseController.query(`SELECT * FROM ${Order.tableName} WHERE id=$1`, [this.id])
                .then(result => {
                // This user has no cart yet
                if (result.rowCount === 0) {
                    console.error(`Order with id(${this.id}) not found!`);
                }
                else {
                    this.id = result.rows[0].id;
                    // get all orderItems with this id, populate array
                    orderProduct_1.OrderProduct.fetchAllBelongingToOrder(this.id).then(result => {
                        this.orderProducts = result;
                        resolve();
                    });
                }
            })
                .catch(err => console.log(err));
        });
    }
    addProduct(productID) {
        return __awaiter(this, void 0, void 0, function* () {
            const cartProductIndex = this.orderProducts.findIndex(cartProduct => cartProduct.product.id === productID);
            let orderProduct = this.orderProducts[cartProductIndex];
            if (orderProduct) {
                orderProduct.quantity++;
            }
            else {
                orderProduct = new orderProduct_1.OrderProduct(this.id, 1);
                yield orderProduct.setup(productID);
                this.orderProducts.push(orderProduct);
            }
            yield orderProduct.save();
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.save();
                resolve();
            }));
        });
    }
    deleteProduct(productID) {
        return __awaiter(this, void 0, void 0, function* () {
            const cartProductIndex = this.orderProducts.findIndex(cartProduct => cartProduct.product.id === productID);
            let cartProduct = this.orderProducts[cartProductIndex];
            console.log(cartProduct);
            yield cartProduct.delete();
            this.orderProducts.splice(cartProductIndex, 1);
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.save();
                resolve();
            }));
        });
    }
    getTotalPrice() {
        return new Promise(resolve => {
            let totalPrice = 0;
            for (const cartProduct of this.orderProducts) {
                for (let i = 0; i < cartProduct.quantity; i++) {
                    totalPrice += cartProduct.product.price;
                }
            }
            resolve(totalPrice);
        });
    }
    static findByColumn(column, value, caseInsensitive) {
        const query = caseInsensitive
            ? `SELECT * FROM ${Order.tableName} WHERE LOWER(${column})=$1`
            : `SELECT * FROM ${Order.tableName} WHERE ${column}=$1`;
        return new Promise(resolve => {
            database_1.DatabaseController.query(query, [value])
                .then(result => {
                resolve(this.createInstanceFromDB(result.rows[0]));
            })
                .catch(err => console.log(err));
        });
    }
    static fetchAllBelongingToUser(userID) {
        return new Promise(resolve => {
            database_1.DatabaseController.query(`SELECT * FROM ${Order.tableName} WHERE belongsToUser=$1`, [
                userID
            ])
                .then((result) => __awaiter(this, void 0, void 0, function* () {
                const orders = [];
                for (const row of result.rows) {
                    yield this.createInstanceFromDB(row).then(result => {
                        orders.push(result);
                    });
                }
                resolve(orders);
            }))
                .catch(err => console.log(err));
        });
    }
    static createInstanceFromDB(dbProduct) {
        return __awaiter(this, void 0, void 0, function* () {
            if (dbProduct === undefined) {
                return undefined;
            }
            const order = new Order(dbProduct.id, dbProduct.belongstouser);
            yield order.load();
            return order;
        });
    }
}
exports.Order = Order;
Order.tableName = 'Orders';
//# sourceMappingURL=order.js.map