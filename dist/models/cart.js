"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const database_1 = require("../controllers/database");
const cartProduct_1 = require("./cartProduct");
const user_1 = require("./user");
//@staticImplements<IDatabaseModelStatic>()
class Cart {
    constructor(belongsToUser) {
        this.id = NaN;
        this.cartProducts = [];
        if (belongsToUser === NaN) {
            console.error('belongsToUser cannot be NaN');
        }
        this.belongsToUser = belongsToUser;
    }
    static init(databaseController) {
        return __awaiter(this, void 0, void 0, function* () {
            return database_1.DatabaseController.query(`CREATE TABLE IF NOT EXISTS ${Cart.tableName}(
          id INT NOT NULL UNIQUE GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          updatedAt TIMESTAMPTZ NOT NULL,
          createdAt TIMESTAMPTZ NOT NULL,
          belongsToUser INT NOT NULL REFERENCES ${user_1.User.tableName}(id) ON DELETE CASCADE ON UPDATE CASCADE
        )`);
        });
    }
    save() {
        return __awaiter(this, void 0, void 0, function* () {
            // Does the cart exist in the app
            let result = !isNaN(this.id);
            const now = new Date();
            if (!result) {
                return new Promise(res => {
                    database_1.DatabaseController.query(`INSERT INTO ${Cart.tableName} (updatedAt, createdAt, belongsToUser) VALUES ($1, $1, $2) RETURNING *`, [now, this.belongsToUser]).then(result => {
                        this.id = result.rows[0].id;
                        res(result);
                    });
                });
            }
            else {
                return database_1.DatabaseController.query(`UPDATE ${Cart.tableName} SET updatedAt=$1 WHERE id=$2`, [
                    now,
                    this.id
                ]);
            }
        });
    }
    delete() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            for (const product of this.cartProducts) {
                yield this.deleteProduct(product.product.id);
            }
            database_1.DatabaseController.query(`DELETE FROM ${Cart.tableName} WHERE id=$1`, [this.id]).then(result => {
                resolve(result);
            });
        }));
    }
    load() {
        return new Promise(resolve => {
            database_1.DatabaseController.query(`SELECT * FROM ${Cart.tableName} WHERE belongsToUser=$1`, [
                this.belongsToUser
            ])
                .then((result) => __awaiter(this, void 0, void 0, function* () {
                // This user has no cart yet
                if (result.rowCount === 0) {
                    yield this.save(); // this assigns id
                    resolve();
                }
                else {
                    this.id = result.rows[0].id;
                    // get all cartItems with this id, populate array
                    cartProduct_1.CartProduct.fetchAllBelongingToCart(this.id)
                        .then(result => {
                        this.cartProducts = result;
                        resolve();
                    })
                        .catch(err => console.log(err));
                }
            }))
                .catch(err => console.log(err));
        });
    }
    addProduct(productID) {
        return __awaiter(this, void 0, void 0, function* () {
            const cartProductIndex = this.cartProducts.findIndex(cartProduct => cartProduct.product.id === productID);
            let cartProduct = this.cartProducts[cartProductIndex];
            if (cartProduct) {
                cartProduct.quantity++;
            }
            else {
                cartProduct = new cartProduct_1.CartProduct(this.id, 1);
                yield cartProduct.setup(productID);
                this.cartProducts.push(cartProduct);
            }
            yield cartProduct.save();
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.save();
                resolve();
            }));
        });
    }
    deleteProduct(productID) {
        return __awaiter(this, void 0, void 0, function* () {
            const cartProductIndex = this.cartProducts.findIndex(cartProduct => cartProduct.product.id === productID);
            let cartProduct = this.cartProducts[cartProductIndex];
            yield cartProduct.delete();
            this.cartProducts.splice(cartProductIndex, 1);
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                yield this.save();
                resolve();
            }));
        });
    }
    getTotalPrice() {
        return new Promise(resolve => {
            let totalPrice = 0;
            for (const cartProduct of this.cartProducts) {
                for (let i = 0; i < cartProduct.quantity; i++) {
                    totalPrice += cartProduct.product.price;
                }
            }
            resolve(totalPrice);
        });
    }
}
exports.Cart = Cart;
Cart.tableName = 'Carts';
//# sourceMappingURL=cart.js.map